## 아이템 19. knowledge를 반복하여 사용하지 말라.

> - 공통적이고 반복되는 코드부분이 있다면, 추출해서 대응하자.(단일 책임 원칙)
> - 물론 반복된다고 모든것을 극단적으로 분리하려하지는 말자. 균현을 맞추자

<details>
<summary>요약</summary>
</details>

---

## 아이템 20. 일반적인 알고리즘을 반복해서 구현하지 말자

> - stdlib에 필요한 기능은 이미 대부분 있다. 이 기능을 활용하자.
> - 직접 정의해서 사용하는 경우라면 확장 함수로 정의하자.

<details>
<summary>요약</summary>
</details>

---
## 아이템 21. 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라.

> - 코틀린의 프로퍼티 위임 매커니즘을 활용하면 아래와 같은 다양한 패턴을 만들 수 있다.
>   - observable 패턴, 리소스 바인딩, 의존성 주입, 데이터 바인딩 ...

<details>
<summary>요약(학습중)</summary>

- 코드 재활용을 위한 프로퍼티 위임
  - 프로퍼티의 행위를 추출해서 재활용할 수 있다.
  - ex) 지연 프로퍼티
  ```kotlin
  val value by lazy { createValue() }
  ```

- 프로퍼티 위임을 사용하면 변화가 있을때 이를 감지하는 observable 패턴도 만들 수 있음.

</details>

---

## 아이템 22. 일반적인 알고리즘을 구현할 때 제네릭을 사용하라

> - 제네릭을 통해 구체적인 타입만 사용하게 타입을 제한할 수 있다.
> - 이를 통해 type-safe 하게 사용할 수 있다.

<details>
<summary>요약(학습중)</summary>
</details>

---

## 아이템 23. 타입 파라미터의 섀도잉을 피하라

> - 클래스에 사용하는 타입파라미터와 함수에 사용하는 타입파라미터 이름이 같은 상황은 피하자.

<details>
<summary>요약(학습중)</summary>
</details>

---

## 아이템 24. 제네릭 타입과 variance 한정자를 활용하라

> - 코틀린은 기본적으로 제네릭을 사용할 때 무공변하다.
> - "in", "out" 한정자를 활용해서 변성을 줄 수 있다.

<details>
<summary>요약(학습중)</summary>
</details>

---

## 아이템 25. 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라

> - 공통된 코틀린 코드를 코틀린/JVM, 코틀린/JS, 코틀린/네이티브 등에서 활용할 수 있다.

<details>
<summary>요약(학습중)</summary>
</details>

---